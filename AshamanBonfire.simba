Program AshamanBonfire;
  {$IFDEF RAYMONDPOWNS}{wrappers} function FloodFillTPAWrap(const TPA: TPointArray): T2DPointArray; var tempATPA: T2DPointArray; begin tempATPA:= FloodFillTPA(TPA); Result:= tempATPA; SetLength(tempATPA, 0); end; function FindTPAEdges(const p: TPointArray): TPointArray; begin FindTPAEdgesWrap(p, result); end; Function RotatePoints(Const P: TPointArray; A, cx, cy: Extended): TPointArray; begin RotatePointsWrap(P, A, cx, cy, result); end; function TPAFromCircle(const CX, CY, Radius: Integer): TPointArray; begin TPAFromCircleWrap(CX, CY, Radius, result); end; function TPAFromEllipse(const CX, CY, XRadius, YRadius : Integer): TPointArray; begin TPAFromEllipseWrap(CX, CY, XRadius, YRadius, result); end; function TPAFromBox(const Box : TBox) : TPointArray; begin TPAFromBoxWrap(Box, result); end; Function ReturnPointsNotInTPA(Const TotalTPA: TPointArray; const Box: TBox): TPointArray; begin ReturnPointsNotInTPAWrap(TotalTPA, Box, result); end; function CombineIntArray(const Ar1, Ar2: TIntegerArray): TIntegerArray; begin CombineIntArrayWrap(Ar1, Ar2, result); end; function ReArrangeandShortenArray(const a: TPointArray; Dist: Integer): TPointArray; begin ReArrangeandShortenArrayWrap(a, Dist, result); end; function ReArrangeandShortenArrayEx(const a: TPointArray; w, h: Integer): TPointArray; begin ReArrangeandShortenArrayExWrap(a, w, h, result); end; function CombineTPA(const Ar1, Ar2: TPointArray): TPointArray; begin CombineTPAWrap(Ar1, Ar2, Result); end; function RemoveDistTPointArray(x, y, dist: Integer;const ThePoints: TPointArray; RemoveHigher: Boolean): TPointArray; begin RemoveDistTPointArrayWrap(x, y, dist, ThePoints, RemoveHigher, Result); end; function TPAFromText(const text, font: String; var w,h: Integer): TPointArray; begin TPAFromTextWrap(text, font, w, h, result); end; function GetColors(const Coords: TPointArray): TIntegerArray; begin GetColorsWrap(Coords, Result); end; function Explode(del, str: string): TStringArray; begin ExplodeWrap(del, str, Result); end; function MergeATPA(const ATPA : T2DPointArray): TPointArray; begin MergeATPAWrap(ATPA, Result); end; function SplitTPA(arr : TPointArray; dist : Integer) : T2DPointArray; begin SplitTPAWrap(arr, dist, result); end; function SplitTPAEx(arr : TPointArray; w, h : integer) : T2DPointArray; begin SplitTPAExWrap(Arr, w, h, result); end; function ClearTPAFromTPA(arP, ClearPoints : TPointArray) : TPointArray; begin ClearTPAFromTPAWrap(arP, ClearPoints, result); end; function TPAToATPAEx(arP : TPointArray; w, h : integer) : T2DPointArray; begin TPAtoATPAExWrap(arP, w, h, result); end; function TPAToATPA(arP : TPointArray; dist : Integer) : T2DPointArray; begin TPAtoATPAWrap(arP, dist, result); end; function FindGapsTPA(TPA : TPointArray; MinPixels : integer) : T2DPointArray; begin FindGapsTPAWrap(tpa, MinPixels, result); end; {$ENDIF}
  {$Define SMART}
  {$I SRL-6/SRL.Simba}
  {$I SPS/SPS-RS3.Simba}

{
AshamanBonfire v2.7
-Make sure zoom is farthest out + srl graphic settings
-Turn off xp popup
-Close ability bar
-Have noted logs in 1st inventory slot (if using POH method)
-Have logs in top right bank slot (if using shantay method)
-Start in front of shantay chest (if using shantay method)
-Start in green field area (if using POH method)
-Have the butler follow you out there (if using POH method)
-DONT WEAR CAPES OR FIRE LOOKING COLORS (NO ORANGES OR BROWNS)
-FILL OUT THE STUFF BELOW
-READ THE OP DIRECTIONS
}

///////////////////////////////////////////////////////////////////////
//                                                                   //
//                  Begin of user setup                              //
//                Fill in the fields below                           //
//                                                                   //
///////////////////////////////////////////////////////////////////////


Const
{General Settings}
  LogType       = 'Maple';           // ***What kind of log are you burning?***
  LogXP         = 135;          // ***How much XP per log do you get? For proggy only (no auto detecting until SRL functions fixed)***
  QuickKey      = 1;          // ***What is the key you've set the logs to? Don't f this up!***
  PrintSmarts   = False;        // ***Proggy on smart? Currently has memory leaks***
  CollectCharms = True;         // ***To collect or not to collect, that is the question NOTE: This option is in beta stages***
  TimeoutFS     = False;        // ***Have shutdown failsafes? Will shutdown if it fails getting logs, or getting xp after 10 minutes***

{Break Settings}
  TakeBreaks    = False;        // ***Take breaks? If false ignore break variables***
  BreakIn       = 600;          // ***How long before we take a break? (minutes)***
  BreakFor      = 15;           // ***How long will we break for? (minutes)***
  Bir           = 13;           // ***Random minutes to add/subtract from how long until we break***
  Bfr           = 7;            // ***Random minutes to add/subjtract from break duraction***

Procedure DeclarePlayers;
Begin
  Players.Setup(['Player1'], 'PlayerList'); //***Fill this out, Player1 = Name of the account in player manager, PlayerList = name of the player file***
  SetLength(Players,1);

  //***If NOT using the player manager, fill out the loginname and password below, otherwise ignore those two***
  With players[0] Do
  Begin
  // loginName := '';      {Remove the "//" from this line if you arent using player manager}
  // password := '';       {Remove the "//" from this line if you arent using player manager}
    IsActive := True;
    World := 100;
  End;
  CurrentPlayer := 0;
End;



///////////////////////////////////////////////////////////////////////////////////////////
//                                                                                       //
//                            End of user setup                                          //
//           Don't touch below this line unless you know what you're doing!!             //
//                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////

Var
  LogCount,XP,StartingExperience,Spirits: Integer;
  StartTime,CurrentTime: Int64;
  CurrentBTime,Timeout: TTimeMarker;
  W,X,Y,Z,BreakRounds,TotalBreaks,RealBTime: Integer;
  RunTime,LogDTM: Integer;
  XPH,LogsPH: Extended;

Const
  ScriptVersion = '3.0';
  Debug = False;
  POSDebug = False;

Procedure SetDTMs;
Begin
  LogDTM := DTMFromString('mwQAAAHicjcwhDoAwDIXht7pxFo7BBdEQJIKAnGBqAQcJV4JfjFlo8rWvFfWSBpMmLBjRoUWf9xmbkyJ2nLiQsCLgQFN7vhFkeb7Zyu2mVx/cD6UeOt4Ohw==');

  W := (BreakIn * 60000);
  X := (BreakFor * 60000);
  Y := RandomRange(-BIR * 60000, BIR * 60000);
  Z := RandomRange(-BFR * 60000, BFR * 60000);
End;

Procedure Fr33DTMs;
Begin
  FreeDTM(LogDTM);
End;

(*
randomRClickItem
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure randomRClickItem();

Randomly rights clicks an item in the backpack, randomly chooses Cancel or
Examine.

.. note::

    - by phantombmx/EvilChicken!, idea by Naum
    - Last Updated: 13 August 2013 by Coh3n

Example:

.. code-block:: pascal

    randomRClickItem();
*)
procedure randomRClickItem(Examine: Boolean); Overload;
var
  t, i: integer;
  slots: TIntegerArray;
begin
  t := gameTabs.getActiveTab();

  if (t <> TAB_BACKPACK) then
    gameTabs.openTab(TAB_BACKPACK);

  if (tabBackpack.count() > 0) then
  begin
    for i := BACKPACK_SLOT_LOW to BACKPACK_SLOT_HIGH do
      if (tabBackpack.isItemInSlot(i)) then
        insert(i, slots);

    tabBackpack.mouseSlot(slots[random(high(slots))], MOUSE_RIGHT);

    if (Examine) then
     chooseOption.select(['xamine'])
    else
     chooseOption.select(['ancel']);

    wait(50 + random(3000));
  end;

  if (t <> TAB_BACKPACK) then
    gameTabs.openTab(t);
end;

Function BreakHandler(BreakIn, BreakFor, randBreakIn, randBreakFor: Integer): Boolean;
Var
  H,M,S: Integer;
Begin
  If Not IsLoggedIn Then
    Exit;

  If (GetTimeRunning < ((W) + (Y) + BreakRounds)) Then
    Exit Else
    If (GetTimeRunning > ((W) + (Y) + BreakRounds)) Then
    Begin
      RealBTime := Round((X+Z)/60000);
      Writeln('Taking a break for about ' + IntToStr(RealBTime) + ' minutes.');
      Players[CurrentPlayer].Logout;
      CurrentBTime.Reset;
      CurrentBTime.Start;
      Repeat
        Wait(21000);
        ConvertTime((X+Z)-CurrentBTime.GetTime,H,M,S);
        Writeln('Breaktime left: '+IntToStr(H)+':'+IntToStr(M)+':'+IntToStr(S));
      Until(CurrentBTime.GetTime>(X+Z));
      Writeln('Logging in.');
      Players[CurrentPlayer].Login;
      Wait(4000);
      Timeout.Reset;
      Timeout.Start;
      Result := IsLoggedIn;
      Minimap.ClickCompass;
      MainScreen.SetAngle(MS_ANGLE_HIGH);
      IncEx(BreakRounds, (W) + (X));
      Inc(TotalBreaks);
      Writeln('The next break will occur in about ' + IntToStr(BreakIn) + ' minutes.');
      W := (BreakIn * 60000);
      X := (BreakFor * 60000);
      Y := RandomRange(-BIR * 60000, BIR * 60000);
      Z := RandomRange(-BFR * 60000, BFR * 60000);
    End;
End;

Procedure DownloadImage(ImageName: String; Location: String);
var
  Image, Path: string;
  FP: Integer;
begin
  Image:= GetPage(Location);
  Path:= IncludePath + ImageName + '.png';
  Path:= Trim(Path);
  FP:= CreateFile(Path);
  WriteFileString(FP, Image);
  CloseFile(FP);
end;

Function GrabMaps: Boolean;
var
  BTFMap: String;    //Map Locations
  BTFName: String;      //Map Names
begin
  BTFName:= '0_0SP';
  BTFMap:= 'http://img607.imageshack.us/img607/3805/c7l2.png';
  begin
    if (Not FileExists(IncludePath + 'SPS\img\runescape_surface\0_0SP.png')) then
      DownloadImage(BTFName, BTFMap);
  end;
  Result:= (FileExists(IncludePath + 'SPS\img\runescape_surface\0_0SP.png'));
end;

Procedure RequirementsCheck;
begin
  If (Not GrabMaps) then
    RaiseException(erCustomError, 'SPS Maps Do Not Exist OR They Are Named Incorrectly!');
end;

//by lejingle!
function MsToTime64(MS: int64): string;
var
  STA: TVariantArray;
  Time: array [0..6] of Integer;
  i: Integer;
begin
  Result := '';
  STA := [' Years, ', ' Months, ', ' Weeks, ', ' Days, ', ' Hours, ',
          ' Minutes and ', ' Seconds', 0];
  ConvertTime64(MS, Time[0], Time[1], Time[2], Time[3], Time[4], Time[5], Time[6]);

  if time[0]= 1 then
    sta[0]:=' Year, ';

  if time[1]= 1 then
    sta[1]:=' Month, ';

  if time[2]= 1 then
    sta[2]:=' Week, ';

  if time[3]= 1 then
    sta[3]:=' Day, ';

  if time[4]= 1 then
    sta[4]:=' Hour, ';

  if time[5]= 1 then
    sta[5]:=' Minute and ';

  if time[6]= 1 then
    sta[6]:=' Second';

  for i := 0 to 6 do
    if (Time[i] > 0) or (STA[7]) or (i = 6) then
      Result := Result + PadZ(IntToStr(Time[i]), STA[7]) + STA[i];
end;

//by Home
function AreaToBoxArray(const AreaX1, AreaY1, AreaX2, AreaY2, Width, Height: Integer): TBoxArray;
var
  AreaW, AreaH: Integer;
  BoxX, BoxY: Integer;
  x, y, i: Integer;
begin
  // Calculate the area dimensions
  AreaW := AreaX2 - AreaX1 + 1;
  AreaH := AreaY2 - AreaY1 + 1;

  // Calculate the number of boxes in each dimension
  BoxX := AreaW div Width;
  if AreaW mod Width <> 0 then Inc(BoxX);
  BoxY := AreaH div Height;
  if AreaH mod Height <> 0 then Inc(BoxY);

  // Set the number of boxes
  SetLength(Result, BoxX * BoxY);

  // Calculate the boxes
  i := 0;
  for y := 0 to BoxY - 1 do
    for x := 0 to BoxX - 1 do
    begin
      Result[i] := IntToBox(AreaX1 + x * Width,
        AreaY1 + y * Height,
        Min(AreaX2, AreaX1 + (x + 1) * Width - 1),
        Min(AreaY2, AreaY1 + (y + 1) * Height - 1));
      Inc(i);
    end;
end;

Procedure CheckMovingObjs(RClick: Boolean);
var
  TBA: TBoxArray;
  MidBox: TPoint;
  TIA: TIntegerArray;
  H,I,J,X,Y,T: Integer;
  TPA,PBox: TPointArray;
begin
  if not IsLoggedIn then Exit;

  SetColorToleranceSpeed(1);
  SetToleranceSpeed2Modifiers(0.2, 0.2);

  PBox := TPAFromBox(MainScreen.PlayerBox);
  TBA := AreaToBoxArray(Mainscreen.X1, Mainscreen.Y1, Mainscreen.X2, Mainscreen.Y2, 35, 35);
  TIA := GetPixelShift(TBA, 300);

  for H := 0 to High(TBA) do
  begin
    if (TIA[H] > 100) then
    begin
      MidBox := MiddleBox(TBA[H]);
      SetArrayLength(TPA, Length(TPA)+1);
      TPA[High(TPA)] := MidBox;
    end;
  end;

  ClearTPAFromTPAWrap(TPA, PBox, TPA);
  if (Length(TPA) < 1) then Exit;

  I := Random(Length(TPA));
  Mouse(Point(TPA[I].X+GaussRangeInt(-10,10), TPA[I].Y+GaussRangeInt(-10,10)),Mouse_Move,Mouse_Human);

  if RClick then
  begin
    FastClick(Mouse_Right);
    if (chooseOption.isOpen(500)) then
      J := Length(ChooseOption.__getOptions());
    Wait(GaussRangeInt(J*75, J*120));

    ChooseOption.Close
  end;
  SetArrayLength(TPA,0);
end;

{*******************************************************************************
Function AutoupdateMe;
By: Shuttleu
Edited By: Ashaman88
Description: Autoupdates Script.
*******************************************************************************}
Procedure AutoUpdateMe;
Var
  Neifile: Integer;
  OnlineVersion, NewScript, NeiFeilNennen: String;
Begin
  Writeln('Checking for script updates...');
  OnlineVersion := GetPage('http://ashamanredsalamander.googlecode.com/git/Version.txt');
  Writeln(OnlineVersion);
  Writeln(ScriptVersion)
  If (trim(OnlineVersion) > ScriptVersion) Then
  Begin
    WriteLn('Newer script version online!');
    WriteLn('Autoupdating to newer version.');
    NewScript := GetPage('http://ashamanredsalamander.googlecode.com/git/AshamanRedSalamander.simba');
    NeiFeilNennen := ScriptPath+ 'Ashaman2IOSalamander V'+OnlineVersion+' by Ashaman88.simba';
    Neifile := Rewritefile(NeiFeilNennen, true);
    Try
      WriteFileString(Neifile, NewScript);
    Except
      Begin
        WriteLn('Fatal error writing to '+NeiFeilNennen+'!!');
        Terminatescript;
      End;
    End;
    CloseFile(Neifile);
    WriteLn('New script downloaded to '+NeiFeilNennen+'!! Please use this one!!');
    TerminateScript;
  End Else
    WriteLn('You have the latest version of the script!');
End;


(*
MmmWeGotOff
~~~~~~~~

.. code-block:: pascal

    Procedure MmmWeGotOff(RedTu: Variant);

Moves the Mouse to the choosen side of the screen, replicating
the use of a human to move thier Mouse "off-screen" as if
browsing another part of their computer.
(What do you do when you browsing "other websites?")
Int Type:

    1 = Go top side, off-screen
    2 = Go left side, off-screen
    3 = Go bottom side, off-screen
    4 = Go right side, off-screen

.. note::

  by Le Jingle.

Example:

.. code-block:: pascal

  MmmWeGotOff(Random(4), 0, 0);

*)
Procedure OffMM(RedTu, LeWait, rWait: Integer);
Var
  W,H,RX,RY,T,RT: Integer;
  OffTimer: TTimeMarker;
Begin
  GetClientDimensions(W,H);
  H:=H+50;
  RX := RandomRange(0, W);
  RY := RandomRange(0, H);
  Case (RedTu) Of
    0..1: Mouse(Point(Round(W/2)+RX, RandomRange(-110,-60)),Mouse_Move,Mouse_Break);
    2: Mouse(Point(RandomRange(-50,-10), Round(H/2)+RY),Mouse_Move,Mouse_Break);
    3: Mouse(Point(Round(W/2)+RX, h+RandomRange(10,50)),Mouse_Move,Mouse_Break);
    4: Mouse(Point(W+RandomRange(10,50), Round(H/2)+RY),Mouse_Move,Mouse_Break);
  End;
  RT:=(Random(rWait));
  OffTimer.Start();
  Repeat
    Wait(GaussRangeInt(100,200));
  Until OffTimer.GetTime()>(LeWait+RT);
End;

Function MakeItemMenu(Time: Integer; Exits: Boolean): Boolean;
Var
  T: TTimeMarker;
  BMP: Integer;
  TPA: TPointArray;
  ATPA: T2DPointArray;
Begin
  If Not IsLoggedIn Then
    Exit;
  T.Start;
  Repeat
    BMP := BitmapFromClient(270,151,307,169);
    GetMufasaBitmap(BMP).FindColors(TPA, 2070783);
    If Debug Then
      DebugBitmap(BMP);
    FreeBitmap(BMP);

    If Not Exits Then
    Begin
      If Debug Then
        Writeln('Searching for ItemMenu to popup');
      If (Length(TPA) > 0) Then
      Begin
        ATPA := TPA.Split(1, 10);

        SortATPAFromFirstPointX(ATPA, [0, 0]);

        If Debug Then
          Writeln(GetTextATPA(ATPA, 3, 'StatChars'));

        If GetTextATPA(ATPA, 3, 'StatChars') = 'Knife' Then
        Begin
          If Debug Then
            Writeln('Found ItemMenu');
          Result:=True;
          SetLength(ATPA,0);
          SetLength(TPA,0);
          Exit;
        End Else
          If Debug Then
            Writeln('No text found');
      End;
    End;

    If Exits Then
    Begin
      If Debug Then
        Writeln('Searching for ItemMenu to leave');
      If (Length(TPA) > 0) Then
      Begin
        ATPA := TPA.Split(1, 10);

        SortATPAFromFirstPointX(ATPA, [0, 0]);

        If Debug Then
          Writeln(GetTextATPA(ATPA, 3, 'StatChars'));

        If GetTextATPA(ATPA, 3, 'StatChars') <> 'Knife' Then
        Begin
          If Debug Then
            Writeln('ItemMenu is gone');
          Result:=True;
          SetLength(ATPA,0);
          SetLength(TPA,0);
          Exit;
        End Else
          If Debug Then
            Writeln('No text found');
      End Else
      Begin
        If Debug Then
          Writeln('ItemMenu is gone');
        Result:=True;
        Exit;
      End;
    End;

    SetLength(ATPA,0);
    SetLength(TPA,0);

    Wait(GaussRangeInt(0,1000));
  Until T.GetTime>Time;
End;

Procedure PrintSmart;
Begin
  SmartImage.Clear;
  SmartImage.DrawText('==========AshamanBonfire==========',Point(320,480),clWhite);
  SmartImage.DrawText('============Version: '+ScriptVersion+'============',Point(145,505),clWhite);
  SmartImage.DrawText('Time Running: ' + ToStr(MsToTime64(CurrentTime)),Point(145,522),clWhite);
  SmartImage.DrawText( 'Experience Earned: ' +ToStr(XP),Point(95,540),clWhite);
  SmartImage.DrawText('Experience/Hour: ' + ToStr(XPH),Point(91,557),clWhite);
  SmartImage.DrawText('==================================',Point(110,570),clWhite);
  If Spirits > 0 Then
    SmartImage.DrawText('Spirits Freed: ' + IntToStr(Spirits),Point(110,570),clWhite);
End;

Procedure ProgressReport;
Begin
  If Not Debug Then
    ClearDebug;

  CurrentTime:= GetSystemTime - StartTime;
  XP := (XP+LogXP);
  XPH := Round(XP * (3600.0 / (GetTimeRunning / 1000.0)));
  LogsPH := Round((LogCount * (3600.0 / (GetTimeRunning / 1000.0))));

  Writeln('==========AshamanBonfire v'+ScriptVersion+'==========');
  Writeln('Burning: ' + LogType);
  Writeln('Time Running: ' + ToStr(MsToTime64(CurrentTime)));
  Writeln('Logs Burned: ' + IntToStr(LogCount));
  Writeln('Experience Earned: ' + IntToStr(XP));
  Writeln('Experience/Hour: ' + ToStr(XPH));
  Writeln('Logs/H: ' + ToStr(LogsPH));
  Writeln('=======================================');

 Timeout.Reset;
 Timeout.Start;

  If PrintSmarts Then
    PrintSmart;
End;

Function CountLogs: Integer;
Var
  X,Y,I: Integer;
Begin
  Result:=TabBackpack.CountDTM(LogDTM);
  If Debug Then
    Writeln(ToStr(Result)+' logs found in inventory');
End;


Function OpenShantayBank: Boolean;
Var
  X,Y,H,I,CTS: Integer;
  T: TTimeMarker;
  ChestBox: TBox;
  TPA,TPA2: TPointArray;
  ATPA,ATPA2: T2DPointArray;
  TBA: TBoxArray;
  MBP: TPoint;
Begin
  Result := False;

  If Not IsLoggedIn Then
    Exit;

  Result:= BankScreen.IsOpen Or PinScreen.IsOpen;
  If Result Then
  Begin
    SetLength(ATPA,0);
    SetLength(TPA,0);
    Exit;
  End;

  If (ChooseOption.OptionsExist(['Exam','mine','Examine','Canc','ncel','Cancel'],400)) Then
  Begin
    If Debug Then
      Writeln('Closing options menu');
    MouseBox(TabBackpack.GetBounds,Mouse_Move);
  End;

  If CountLogs>0 Then
    Exit;

  CTS := GetToleranceSpeed;
  SetColorToleranceSpeed(2);

  SetToleranceSpeed2Modifiers(0.13,0.38);
  FindColorsSpiralTolerance(MainScreen.PlayerPoint.X,MainScreen.PlayerPoint.Y,TPA,6258330,MainScreen.GetBounds.X1,MainScreen.GetBounds.Y1,MainScreen.GetBounds.X2,MainScreen.GetBounds.Y2,4);
  SetColorToleranceSpeed(CTS);
  SetToleranceSpeed2Modifiers(0.2,0.2);

  ATPA := TPAtoATPAEx(TPA,10,10);
  SortATPAFromFirstPointY(ATPA,Point(316,195));

  If (Length(ATPA) = 0) Then
  Begin
    If Debug Then
      Writeln('No booth found.');
    Exit;
  End;

  If Debug Then
    Try
      DebugATPABounds(ATPA);
    Except
      Writeln('Box out of bounds');
    End;

  H := High(ATPA);

  For I:= 0 To H Do
  Begin
    If (Length(ATPA[I]) < 50) Or (Length(ATPA[I]) > 100)  Then
      Continue;

    If Debug Then
      Writeln('Chest Length: '+ToStr(Length(atpa[i]))+' for I:= '+ToStr(I));

    ChestBox := GetTPABounds(ATPA[I]);
    ChestBox := IntToBox(Max(ChestBox.X1,0),Max(ChestBox.Y1,0),Min(ChestBox.X2,Mainscreen.X2),Min(ChestBox.Y2,Mainscreen.Y2));

    With ChestBox Do
    Begin
      If Not IsLoggedIn Then
        Exit;

      SetToleranceSpeed2Modifiers(0.00,0.43);
      FindColorsSpiralTolerance(MainScreen.PlayerPoint.X,MainScreen.PlayerPoint.Y,TPA2,3684414,ChestBox.X1,ChestBox.Y1,ChestBox.X2,ChestBox.Y2,3);
      SetColorToleranceSpeed(CTS);
      SetToleranceSpeed2Modifiers(0.2,0.2);

      If Length(TPA2) > 3 Then
      Begin
        SetArrayLength(TBA, Length(TBA)+1);
        TBA[High(TBA)] := ChestBox;
      End;
    End;
  End;

  If Debug Then
  Try
    SmartImage.Clear;
    SmartImage.DrawBoxes(TBA, False, clRed);
  Except
    Writeln('Failed Drawing Boxes.');
  End;

  SetLength(TPA,0);
  SetLength(ATPA,0);
  SetLength(TPA2,0);
  SetLength(ATPA2,0);

  For H := 0 To High(TBA) Do
  Begin
    MBP := MiddleBox(TBA[H]);

    If (ChooseOption.OptionsExist(['Exam','mine','Examine','Canc','ncel','Cancel'],400)) Then
    Begin
      If Debug Then
        Writeln('Closing options menu');
      MouseBox(TabBackpack.GetBounds,Mouse_Move);
    End;


    Result:= BankScreen.IsOpen Or PinScreen.IsOpen;
    If Result Then
      Break;

    MBP := MiddleBox(TBA[H]);

    Mouse(Point(MBP.X+GaussRangeInt(-10,10),MBP.Y+GaussRangeInt(-10,10)),Mouse_Move,Mouse_Human);

    If (IsMouseOverText(['Open','pen','chest','ches','hest'],300)) Then
    Begin
      If Debug Then
        Writeln('Found chest, Clicking.');

      FastClick(Mouse_Right);

      If ChooseOption.Select(['Open','chest'],RandomRange(700,900)) Then
      Begin
        T.Start;
        Repeat
          If Not IsLoggedIn Then
            Exit;
          If T.GetTime>6000 Then
          Begin
            If Debug Then
              Writeln('Took too long to open chest');
            SetLength(ATPA,0);
            SetLength(TPA,0);
            Exit;
          End;
          Wait(Random(100));
        Until BankScreen.IsOpen Or PinScreen.IsOpen;
        SetLength(ATPA,0);
        SetLength(TPA,0);
        Result:=True;
        Exit;
      End;
    End;
  End;
  SetLength(ATPA,0);
  SetLength(TPA,0);
End;

Function BankShantay: Boolean;
Var
  P: TPoint;
  T: TTimeMarker;
Begin
  Result:=False;

  If (Not WaitFunc(@OpenShantayBank,100,8000)) And (Not BankScreen.IsOpen) Then
    If SPS.BlindWalk(Point(110,126)) Then
    Begin
      While Minimap.IsPlayerMoving Do
        Wait(1000);
      If (Not WaitFunc(@OpenShantayBank,100,8000)) And (Not BankScreen.IsOpen) Then
        Exit;
    End Else
      If Minimap.FindSymbol(P,MM_SYMBOL_BANK, Minimap.GetBounds) Then
      Begin
        Mouse(X+10+GaussRangeInt(-2,2),Y-10+GaussRangeInt(-2,2),Mouse_Left,Mouse_Human);
        Wait(RandomRange(5000,9000));
        Minimap.ClickCompass;
        MainScreen.SetAngle(MS_ANGLE_HIGH);
        If (Not WaitFunc(@OpenShantayBank,100,8000)) And (Not BankScreen.IsOpen) Then
          Exit;
      End Else
      Begin
        Mouse(Point(628,150),Mouse_Left,Mouse_Human);
        FastClick(Mouse_left);
        Wait(RandomRange(5000,9000));
        If (Not WaitFunc(@OpenShantayBank,100,8000)) And (Not BankScreen.IsOpen) Then
          Exit;
      End;

  T.Start;
  Repeat
    If Not IsLoggedIn Then
      Exit;
    If T.GetTime>6000 Then
    Begin
      If Debug Then
        Writeln('Took too long to open bank');
      Exit;
    End;
    Wait(Random(100));
  Until BankScreen.IsOpen Or PinScreen.IsOpen;

  If PinScreen.IsOpen Then
    PinScreen.Enter(Players[CurrentPlayer].BankPin);

  If BankScreen.GetPackCount > 0 Then
    BankScreen.QuickDeposit(QUICK_DEPOSIT_INVENTORY);

  T.Reset;
  T.Start;
  Repeat
    Wait(Random(100));
    If BankScreen.Withdraw(10, WITHDRAW_AMOUNT_ALL, ['']) Then
      Break;
    If ChooseOption.Select(['Withdraw-All', 'w-A']) Then
      Break;
    If Not IsLoggedIn Then
      Exit;
    If T.GetTime>10000 Then
    Begin

      Writeln('Out of logs');
      Writeln('Screenshot saved, send to Ashaman if you"re not really out of bars!');
      SaveScreenshot(ScriptPath + '/fail_.bmp');
      If Not TimeoutFS Then
        Exit;
      TerminateScript;
    End;
  Until T.GetTime>20000;
  BankScreen.Close;

  T.Reset;
  T.Start;
  Repeat
    Wait(Random(152));
    If Not IsLoggedIn Then
      Break;
    If T.GetTime>5000 Then
    Begin
      Writeln('Inventory still not full, WTF??');
      If Not TimeoutFS Then
        Exit;
      TerminateScript;
    End;
  Until TabBackpack.IsFull;

  Result:=True;
End;

Procedure MoveAway;
Begin
  Case Random(3) Of
    0:
    Begin
      Mouse(Point(Mainscreen.PlayerPoint.X-30+GaussRangeInt(-4,4),Mainscreen.PlayerPoint.Y-30+GaussRangeInt(-4,4)),Mouse_Right,Mouse_Human);
      ChooseOption.Select(['alk'],900);
    End;
    1:
    Begin
      Mouse(Point(Mainscreen.PlayerPoint.X-30+GaussRangeInt(-4,4),Mainscreen.PlayerPoint.Y+30+GaussRangeInt(-4,4)),Mouse_Right,Mouse_Human);
      ChooseOption.Select(['alk'],900);
    End;
    2:
    Begin
      Mouse(Point(Mainscreen.PlayerPoint.X-30+GaussRangeInt(-4,4),Mainscreen.PlayerPoint.Y+GaussRangeInt(-4,4)),Mouse_Right,Mouse_Human);
      ChooseOption.Select(['alk'],900);
    End;
  End;

  Wait(RandomRange(1000,2000));
  While Minimap.IsPlayerMoving Do
    Wait(100);
End;

Function LightFire:Boolean;
Begin
  If Not IsLoggedIn Then
    Exit;

  If TabBackpack.ClickDTM(LogDTM,Mouse_Right,'ight',0,False) Then
    If TabBackpack.WaitForShift(5000) Then
    Begin
      Result:= True;
      Wait(RandomRange(3000,3500));
    End Else
      MoveAway;
End;

Function FindFire: Boolean;
Begin
  If Not IsLoggedIn Then
    Exit;

  Result:=False;

  ExitSquealOfFortune;
  ClaimSpinTicket;


  Wait(Random(100));

  If FindDTM(LogDTM,X,Y,TabBackpack.GetBounds) Then
  Begin
    TypeSend(ToStr(QuickKey),False);
    Wait(Random(100));
    MouseBox(IntToBox(369,186,411,230),Mouse_Move,Mouse_Break);
    If MakeItemMenu(6000,False) Then
    Begin
      Wait(GaussRangeInt(500,1500));
      FastClick(Mouse_Left);
      If MakeItemMenu(6000,True) Then
        If ChatBox.FindTextOnLines(['ran'],[2]) Then
        Begin
          Wait(Random(100));
          RandomRClickItem(True);
          MoveAway;
          LightFire;
        End Else
          If TabBackpack.WaitForShift(5000) Then
          Begin
            Result:= True;
            Wait(RandomRange(1000,1400));
          End;
    End;
  End;
End;

Function FindSpirit: Boolean;
Var
  I,H,X,Y: Integer;
  TPA  : TPointArray;
  ATPA : T2DPointArray;
  CTS : Integer;
Begin
  If Not IsLoggedIn Then
    Exit;

  Result:=False;

  CTS := GetToleranceSpeed;
  SetColorToleranceSpeed(2);

  SetToleranceSpeed2Modifiers(0.18,0.84);

  FindColorsSpiralTolerance(MainScreen.PlayerPoint.X,MainScreen.PlayerPoint.Y,TPA,3693463,Mainscreen.PlayerBox.X1-15,Mainscreen.PlayerBox.Y1-15,Mainscreen.PlayerBox.X2+15,Mainscreen.PlayerBox.Y2+15,9);
  SetColorToleranceSpeed(CTS);
  SetToleranceSpeed2Modifiers(0.2, 0.2);

  ATPA := TPAtoATPAEx(TPA,20,20);
  SortATPASize(ATPA,True);

  H := High(ATPA);

  For I := 0 To H Do
  Begin
    MiddleTPAEx(ATPA[I],X,Y);

    If (ChooseOption.OptionsExist(['Exam','mine','Examine','Canc','ncel','Cancel'],400)) Then
    Begin
      If Debug Then
        Writeln('Closing options menu');
      MouseBox(TabBackpack.GetBounds,Mouse_Move);
    End;

    Mouse(X+GaussRangeInt(-5,5),Y+GaussRangeInt(-5,5),Mouse_Move,Mouse_Human);
    If IsMouseOverText(['emon','spirit','rit','ee','Coll','-sp','ward','reward''ewar'],RandomRange(150,200)) Then
    Begin
      FastClick(Mouse_Right);
      If ChooseOption.Select(['spirit','rit','ee'],750) Then
      Begin
        TabBackpack.WaitForShift(2000);
        BankShantay;
        Result:=True;
        Inc(Spirits);
        SetLength(ATPA,0);
        SetLength(TPA,0);
        Exit;
      End;
    End;
  End;
  SetLength(ATPA,0);
  SetLength(TPA,0);
End;

Function Antiban: Boolean;
Var
  I: Integer;
Begin
  I := Random(600);
  Case I Of
    1..3:
      Begin
        MouseOffClient(Random(4));
        Result := True;
      End;
    4..7:
      Begin
        TabStats.GetSkillLevel(Skill_Firemaking);
        TabBackpack.Open;
        Result := True;
      End;
    8..50:
      Begin
        CheckMovingObjs(False);
        Result := True;
      End;
    51..200:
      Begin
        SleepAndMoveMouse(GaussRangeInt(400,500));
        Result:=True;
      End;
    201..400:
      Begin
        OffMM(Random(4),GaussRangeInt(2500,4000),5000);
        Result:=True;
      End;
    401..600:
      Begin
        Wait(RandomRange(250, 1500));
        Result:=True;
      End;
  End;
  If TabBackpack.Count>5 Then
    Wait(GaussRangeInt(3500, 3600));
End;

Procedure Waiting;
Var
  Inv1: Integer;
  T: TTimeMarker;
Begin
  If Not IsLoggedIn Then
    Exit;

  T.Start;
  Inv1:= TabBackpack.Count;
  Repeat
    Wait(Random(100));
    If Not IsLoggedIn Then
      Exit;

    If ChatBox.FindTextOnLines(['ran'],[2]) Then
    Begin
      RandomRClickItem(True);
      Exit;
    End;

    If TabBackpack.Count>4 Then
      AntiBan;

    If CollectCharms Then
      If (ChatBox.FindTextOnLines(['emerges'],[2])) And (TabBackpack.Count<22) Then
        If WaitFunc(@FindSpirit,100,RandomRange(12000,18000)) Then
          Break Else
          RandomRClickItem(True);


    If Inv1>TabBackPack.Count Then
    Begin
      Inv1:=TabBackPack.Count;
      If Debug Then
        Writeln('Inventory changed');
      T.Reset;
      T.Start;
      Timeout.Reset;
      Timeout.Start;
    End;

    If (ClaimSpinTicket) Or (Not IsLoggedIn) Then
      Exit;
  Until (CountLogs=0) or (T.GetTime>8000);
End;

Procedure Mainloop;
Begin
  ExitSquealOfFortune;
  ClaimSpinTicket;

  If CountLogs=0 Then
    If WaitFunc(@BankShantay,100,20000) Then
      If Not TabBackpack.IsFull Then
        If Not TabBackpack.WaitForShift(GaussRangeInt(0,5000)) Then
          If Not TabBackpack.IsFull Then
            Exit;

  LogCount:=LogCount+(CountLogs);

  If FindFire Then
    Waiting;

  ExitSquealOfFortune;
  ClaimSpinTicket;

  If CountLogs=0 Then
    ProgressReport;

  If Timeout.GetTime>600000 Then
  Begin
    Writeln('Something went wrong, shutting down');
    If Not TimeoutFS Then
      Exit;
    Players[CurrentPlayer].Logout;
    TerminateScript;
  End;

  If Timeout.GetTime>300000 Then
  Begin
    Writeln('Something went wrong, resetting stuff');
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    BankShantay;
  End;

  If Not IsLoggedIn Then
  Begin
    Players[CurrentPlayer].Login;
    Wait(GaussRangeInt(2000,4000));
    MouseBox(IntToBox(19,485,40,501),Mouse_Left,Mouse_Human);
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    Timeout.Reset;
    Timeout.Start;
    ExitSquealOfFortune;
    ClaimSpinTicket;
  End;

  If TakeBreaks Then
    BreakHandler(BreakIn,BreakFor,Bir,Bfr);
  Wait(Random(100));
End;


Procedure Setup;
Begin
  DisableSRLDebug:=True;
  SmartEnableDrawing := True;
  SetupSRL;
  RequirementsCheck;
  SPS.Setup('0_0SP', 'Runescape_Surface\');

  AddOnTerminate('Fr33DTMs');
  SetDTMs;

  ClearDebug;

  DeclarePlayers;

  Players[CurrentPlayer].Login;
  Wait(GaussRangeInt(2000,4000));
  MouseBox(IntToBox(19,485,40,501),Mouse_Left,Mouse_Human);

  Minimap.ClickCompass;
  MainScreen.SetAngle(MS_ANGLE_HIGH);

 // StartingExperience := GetXPBarTotal;

  Players[CurrentPlayer].FindMod := False;
  ExitSquealOfFortune;
  ClaimSpinTicket;

  If ActionBar.IsSlotEmpty(1) Then
  Begin
    Writeln('The quickkey you have set is not set to logs, shutting down');
    TerminateScript;
  End;

  If TabBackpack.Count>1 Then
    LogCount:=CountLogs;

 // SetAllChats('filter','off','off','off','off','off','off');
  Timeout.Start;
  SmartImage.Clear;
  If POSDebug Then
    If SPS.BlindWalk(Point(110,126)) Then
      Writeln('Woot');

  Writeln('Looks like we are doing bonfires at Shantay Pass!');

  StartTime:=GetSystemTime;
  Writeln('Lets get this show on the road!');
End;

Begin
  Setup;

  While (Players.GetActive() > 0) Do
    If Not POSDebug Then
      Mainloop Else
      SPS.DebugPlayerPos;

  If (Not IsLoggedIn) Then
  Begin
    Writeln('Script ended, not logged in or all players inactive');
    TerminateScript;
  End;

  If Not TabBackpack.IsFull Then
  Begin
    Writeln('Script ended, out of materials');
    Players[CurrentPlayer].Logout;
  End;
End.
