///////////////////////////////////////////////////////////////////////
//                                                                   //
//          READ THE DIRECTIONS IN THE OP FIRST OR ELSE              //
//           Make sure you have setup your player file               //
//                  Under SRL>PlayerManager                          //
//                       Press Play                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
//                                                                                       //
//           Don't touch below this line unless you know what you're doing!!             //
//                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////


program AshamanBonfire;
  {$IFDEF RAYMONDPOWNS}{wrappers} function FloodFillTPAWrap(const TPA: TPointArray): T2DPointArray; var tempATPA: T2DPointArray; begin tempATPA:= FloodFillTPA(TPA); Result:= tempATPA; SetLength(tempATPA, 0); end; function FindTPAEdges(const p: TPointArray): TPointArray; begin FindTPAEdgesWrap(p, result); end; Function RotatePoints(Const P: TPointArray; A, cx, cy: Extended): TPointArray; begin RotatePointsWrap(P, A, cx, cy, result); end; function TPAFromCircle(const CX, CY, Radius: Integer): TPointArray; begin TPAFromCircleWrap(CX, CY, Radius, result); end; function TPAFromEllipse(const CX, CY, XRadius, YRadius : Integer): TPointArray; begin TPAFromEllipseWrap(CX, CY, XRadius, YRadius, result); end; function TPAFromBox(const Box : TBox) : TPointArray; begin TPAFromBoxWrap(Box, result); end; Function ReturnPointsNotInTPA(Const TotalTPA: TPointArray; const Box: TBox): TPointArray; begin ReturnPointsNotInTPAWrap(TotalTPA, Box, result); end; function CombineIntArray(const Ar1, Ar2: TIntegerArray): TIntegerArray; begin CombineIntArrayWrap(Ar1, Ar2, result); end; function ReArrangeandShortenArray(const a: TPointArray; Dist: Integer): TPointArray; begin ReArrangeandShortenArrayWrap(a, Dist, result); end; function ReArrangeandShortenArrayEx(const a: TPointArray; w, h: Integer): TPointArray; begin ReArrangeandShortenArrayExWrap(a, w, h, result); end; function CombineTPA(const Ar1, Ar2: TPointArray): TPointArray; begin CombineTPAWrap(Ar1, Ar2, Result); end; function RemoveDistTPointArray(x, y, dist: Integer;const ThePoints: TPointArray; RemoveHigher: Boolean): TPointArray; begin RemoveDistTPointArrayWrap(x, y, dist, ThePoints, RemoveHigher, Result); end; function TPAFromText(const text, font: String; var w,h: Integer): TPointArray; begin TPAFromTextWrap(text, font, w, h, result); end; function GetColors(const Coords: TPointArray): TIntegerArray; begin GetColorsWrap(Coords, Result); end; function Explode(del, str: string): TStringArray; begin ExplodeWrap(del, str, Result); end; function MergeATPA(const ATPA : T2DPointArray): TPointArray; begin MergeATPAWrap(ATPA, Result); end; function SplitTPA(arr : TPointArray; dist : Integer) : T2DPointArray; begin SplitTPAWrap(arr, dist, result); end; function SplitTPAEx(arr : TPointArray; w, h : integer) : T2DPointArray; begin SplitTPAExWrap(Arr, w, h, result); end; function ClearTPAFromTPA(arP, ClearPoints : TPointArray) : TPointArray; begin ClearTPAFromTPAWrap(arP, ClearPoints, result); end; function TPAToATPAEx(arP : TPointArray; w, h : integer) : T2DPointArray; begin TPAtoATPAExWrap(arP, w, h, result); end; function TPAToATPA(arP : TPointArray; dist : Integer) : T2DPointArray; begin TPAtoATPAWrap(arP, dist, result); end; function FindGapsTPA(TPA : TPointArray; MinPixels : integer) : T2DPointArray; begin FindGapsTPAWrap(tpa, MinPixels, result); end; {$ENDIF}
  {$Define SMART}
  {$I SRL-6/SRL.Simba}
  {$i srl-6/lib/misc/srlplayerform.simba}
  {$I SPS/lib/SPS-RS3.Simba}

var
  LogCount, XP, StartingExperience, Spirits, XPH, LogsPH: Extended;
  CurrentBTime, Timeout, Reset: TTimeMarker;
  W, X, Y, Z, BreakRounds, TotalBreaks, RealBTime: Integer;
  LogDTM, TimeoutLength, ResetLength: Integer;
  debug: boolean;
  FunctionStop: String;

Const
  scriptVersion = '3.5';
  POSDebug = False;

procedure declarePlayers();
var
  i,j: integer;
begin
  players.setup(playerForm.playerNames, playerForm.playerFile); // load the SPF players from the SRL Player Manager
  currentPlayer := 0;                                           // player to use first

  // set player attributes based on the settings from the form
  for i := 0 to high(players) do
    with players[i] do
    begin
      // convert the integers
      integers[0] := strToInt(playerForm.players[i].settings[1]);  //minutes until break
      integers[1] := strToInt(playerForm.players[i].settings[2]);  //minutes to break

      World :=  100;                    //world


      // booleans
      booleans[0] := strToBool(playerForm.players[i].settings[3]);    //take breaks
      booleans[1] := strToBool(playerForm.players[i].settings[5]);    //find spirits
      FindMod := strToBool(playerForm.players[i].settings[4]);        //logmod
      debug := strToBool(playerForm.players[i].settings[6]);  //debug

      // any other data types you've decided to use
      strings[0] := playerForm.players[i].settings[0]; //quickkey
      strings[1] := playerForm.players[i].settings[7]; //logtype
    end;
end;

procedure initPlayerForm();
begin
  with playerForm do
  begin
    name := 'AshamanBonfire v'+toStr(ScriptVersion);
    scriptHelpThread := '';
    scriptSettingsPath := '';

    editBoxLabels := ['QuickKey', 'Minutes until Break', '# of Minutes to Break'];
    editBoxDefaults := [ '0', '600', '15'];
    checkBoxLabels := ['Take Breaks', 'Logout if Mod is near', 'Find Spirits', 'DebugMode'];
    checkBoxDefaults := ['True','True','True', 'False'];

    comboBoxLabels := ['LogType'];
    comboBoxDefaults := ['Maple'];

    setLength(comboBoxItems, length(comboBoxLabels));
    comboBoxItems[0] := ['Normal', 'Oak', 'Willow', 'Teak', 'Maple', 'Mahogany', 'Eucalyptus', 'Yew', 'Magic', 'Elder'];
  end;
end;

Procedure SetDTMs;
Begin
  FUNCTIONSTOP:='SetDTMs ENTERED';
  LogDTM := DTMFromString('mwQAAAHic42RgYOAFYmkgFgVibgYI4ILyZYBYEqpGFCrHAlUHEhcDYj4gZgViFx1OIMkIxExImBFJjJEhBaoWH2YkAsMBABO8AjM=');

  W := (Players[CurrentPlayer].integers[0] * 60000);
  X := (Players[CurrentPlayer].integers[1] * 60000);
  Y := RandomRange(-13 * 60000, 13 * 60000);
  Z := RandomRange(-7 * 60000, 7 * 60000);

  FUNCTIONSTOP:='SetDTMs EXIT';
End;

Procedure Fr33DTMs;
Begin
  FreeDTM(LogDTM);
End;

Function BreakHandler(BreakIn, BreakFor, randBreakIn, randBreakFor: Integer): Boolean;
Var
  H,M,S: Integer;
Begin
  FUNCTIONSTOP:='BREAK ENTERED';

  If Not IsLoggedIn Then
    Exit;

  If (GetTimeRunning < ((W) + (Y) + BreakRounds)) Then
    Exit Else
    If (GetTimeRunning > ((W) + (Y) + BreakRounds)) Then
    Begin
      RealBTime := Round((X+Z)/60000);
      Writeln('Taking a break for about ' + IntToStr(RealBTime) + ' minutes.');
      Players[CurrentPlayer].Logout;
      CurrentBTime.Reset;
      CurrentBTime.Start;
      Repeat
        Wait(21000);
        ConvertTime((X+Z)-CurrentBTime.GetTime,H,M,S);
        Writeln('Breaktime left: '+IntToStr(H)+':'+IntToStr(M)+':'+IntToStr(S));
      Until(CurrentBTime.GetTime>(X+Z));
      Writeln('Logging in.');
      Players[CurrentPlayer].Login;
      Wait(4000);
      Timeout.Start;
      Reset.Reset;
      Reset.Start;
      Result := IsLoggedIn;
      Minimap.ClickCompass;
      MainScreen.SetAngle(MS_ANGLE_HIGH);
      IncEx(BreakRounds, (W) + (X));
      Inc(TotalBreaks);
      Writeln('The next break will occur in about ' + IntToStr(Players[CurrentPlayer].integers[0]) + ' minutes.');
      W := (Players[CurrentPlayer].integers[0] * 60000);
      X := (Players[CurrentPlayer].integers[1] * 60000);
      Y := RandomRange(-13 * 60000, 13 * 60000);
      Z := RandomRange(-7 * 60000, 7 * 60000);
    End;
  FUNCTIONSTOP:='BREAK EXIT';
End;

Function GrabMaps: Boolean;
var
  Map: String;    //Map Locations
  Name: String;      //Map Names
  SPSFile: LongInt;
begin
  Name:= IncludePath + 'SPS\img\runescape_surface\0_0SP.png';
  Map:= 'http://img607.imageshack.us/img607/3805/c7l2.png';
  begin
    if (Not FileExists(Name)) then
    begin
      writeln('No file, downloading');
      SPSFile:=CreateFile(Name);
      CloseFile(SPSFile);
      SPSFile:= RewriteFile(Name, False);
      WriteFileString(SPSFile, GetPage(Map));
      CloseFile(SPSFile);
    end;
  end;
  Result:= (FileExists(IncludePath + 'SPS\img\runescape_surface\0_0SP.png'));
end;

Procedure RequirementsCheck;
begin
  If (Not GrabMaps) then
    RaiseException(erCustomError, 'SPS Maps Do Not Exist OR They Are Named Incorrectly!');
end;

{*******************************************************************************
Function AutoupdateMe;
By: Shuttleu
Edited By: Ashaman88
Description: Autoupdates Script.
*******************************************************************************}
Procedure AutoUpdateMe;
Var
  Neifile: Integer;
  OnlineVersion, NewScript, NeiFeilNennen: String;
Begin
  Writeln('Checking for script updates...');
  OnlineVersion := GetPage('http://ashamanbonfire.googlecode.com/git/Version.txt');
  Writeln(OnlineVersion);
  Writeln(ScriptVersion)
  If (trim(OnlineVersion) > ScriptVersion) Then
  Begin
    WriteLn('Newer script version online!');
    WriteLn('Autoupdating to newer version.');
    NewScript := GetPage('http://ashamanbonfire.googlecode.com/git/AshamanBonfire.simba');
    NeiFeilNennen := ScriptPath+ 'AshamanBonfire V'+OnlineVersion+'.simba';
    Neifile := Rewritefile(NeiFeilNennen, true);
    Try
      WriteFileString(Neifile, NewScript);
    Except
      Begin
        WriteLn('Fatal error writing to '+NeiFeilNennen+'!!');
        Terminatescript;
      End;
    End;
    CloseFile(Neifile);
    WriteLn('New script downloaded to '+NeiFeilNennen+'!! Please use this one!!');
    TerminateScript;
  End Else
    WriteLn('You have the latest version of the script!');
End;

Function FirePresent: Boolean;
Var
  MB: TBox;
  TPA: TPointArray;
  fireColors: T2DColorData;
Begin
  If Not IsLoggedIn Then
    Exit;

  Result:=False;

  MB:=Mainscreen.PlayerBox;
  MB.Edit(-80,-80,+80,+80);
                      //logs
  fireColors := [[1808090, 9, [2, [0.24, 2.45, 0.00]]], [6352889, 12, [2, [0.10, 0.61, 0.00]]]];

  if (fireColors.gatherIn(tpa, mb)) then
    result:=length(tpa)>50;
  setlength(tpa,0);
End;

Procedure PrintSmart;
Begin
  SmartImage.Clear;
  SmartImage.DrawText('==========AshamanBonfire==========',Point(11,319),clWhite);
  SmartImage.DrawText('============Version: '+ScriptVersion+'============',Point(11,319+10),clWhite);
  SmartImage.DrawText('Time Running: ' + ToStr(TimeRunning),Point(11,319+20),clWhite);
  SmartImage.DrawText('Experience Earned: ' +ToStr(XP),Point(11,319+30),clWhite);
  SmartImage.DrawText('Experience/Hour: ' + ToStr(XPH),Point(11,319+40),clWhite);
  SmartImage.DrawText('==================================',Point(11,319+50),clWhite);
  If Spirits > 0 Then
    SmartImage.DrawText('Spirits Freed: ' + ToStr(Spirits),Point(11,319+60),clWhite);
End;

function TRSChatBox.getXP: Integer;
var
  b: TBox;
  s: String;
  tpa : TPointArray;
  atpa : T2DPointArray;
  i,cts,p,p2: Integer;
begin
  result := -1;

  b := [self.x2 - 199, self.y1 + 10, self.x2, self.y2 - 92];

  findColorsTolerance(tpa, 14013909, b, 4, colorSetting(2, 0.00, 0.00));

  if length(tpa) < 2 then
  begin
    print('chatBox.getXP(): No XP found', TDebug.SUB);
    exit;
  end;

  atpa := tpa.cluster(10);
  atpa.sortBySize;

  b := atpa[low(atpa)].getbounds;
  b.edit(-2,-2,+2,+3);

  s := Replace(tesseractgettext(b.x1,b.y1,b.x2,b.y2, FILTER_SMALL_CHARS_2), ' ', '', [rfReplaceAll]);

  P := Pos('x', S);
  P2 := Pos('X', S);
  if (P > 0) Or (P2 > 0) then
    Result := StrToIntDef(ExtractFromStr(Copy(s, P, Length(S)), Numbers), 0)
  else
    Result := StrToIntDef(ExtractFromStr(S, Numbers), 0);

  print('chatBox.getXP(): XP found: ' + tostr(result), TDebug.SUB);
end;

Procedure ProgressReport;
Begin
  If Not Debug Then
    ClearDebug;

  XP := (ChatBox.GetXP - Round(StartingExperience));
  XPH := Round(XP * (3600.0 / (GetTimeRunning / 1000.0)));
  LogsPH := Round((LogCount * (3600.0 / (GetTimeRunning / 1000.0))));

  writeln('|=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=|');
  writeln('|                   AshamanBonfire v'+PadR(toStr(ScriptVersion), 24), '|');
  writeln('|=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=|');
  writeln(PadR('| Running For: '+TimeRunning, 60)+'|');
  writeln(PadR('| '+Players[CurrentPlayer].strings[1]+'''s Burned: ' + GroupDigits(LogCount,','), 40) + padR('Logs/H: ' + GroupDigits(LogsPH,','), 20) + '|');
  writeln(PadR('| Exp Earned: ' + GroupDigits(XP,','), 40) + padR('Exp/Hour: ' + GroupDigits(XPH,','), 20) + '|');
  writeln('|___________________________________________________________|');
  writeln('|___________________________________________________________|');

 Timeout.Start;
 Reset.Start;

 PrintSmart;
End;

Function CountLogs: Integer;
Var
  X,Y,I: Integer;
Begin
  FUNCTIONSTOP:='COUNTLOGS ENTERED';

  Result:=TabBackpack.CountDTM(LogDTM);
  If Debug Then
    Writeln(ToStr(Result)+' logs found in inventory');

  FUNCTIONSTOP:='COUNTLOGSEXIT';
End;

Function BankShantay: Boolean;
Var
  P: TPoint;
  T: TTimeMarker;
  Time: Integer;
Begin
  FUNCTIONSTOP:='BANKSHANTAY ENTERED';

  If Not IsLoggedIn Then
    Exit;

  T.Start;
  If (Not Bankscreen.Open(BANK_CHEST_SHANTAY)) And (Not BankScreen.IsOpen) Then
    If SPS.BlindWalk(Point(110,126)) Then
    Begin
      While (Minimap.IsPlayerMoving) And (T.GetTime < GaussRangeInt(10000,20000)) Do
        Wait(1000);
      If (Not Bankscreen.Open(BANK_CHEST_SHANTAY)) And (Not BankScreen.IsOpen) Then
        Exit;
    End Else
      If Minimap.FindSymbol(P,MM_SYMBOL_BANK, Minimap.GetBounds) Then
      Begin
        Mouse(X+10+GaussRangeInt(-2,2),Y-10+GaussRangeInt(-2,2),Mouse_Left,Mouse_Human);
        Wait(RandomRange(5000,9000));
        Minimap.ClickCompass;
        MainScreen.SetAngle(MS_ANGLE_HIGH);
        If (Not Bankscreen.Open(BANK_CHEST_SHANTAY)) And (Not BankScreen.IsOpen) Then
          Exit;
      End Else
      Begin
        Mouse(Point(628,150),Mouse_Left,Mouse_Human);
        FastClick(Mouse_left);
        Wait(GaussRangeInt(3000,6000));
        If (Not Bankscreen.Open(BANK_CHEST_SHANTAY)) And (Not BankScreen.IsOpen) Then
          Exit;
      End;

  Time:=GaussRangeInt(3000,8000);
  T.Start;
  Repeat
    If Not IsLoggedIn Then
      Exit;
    If T.GetTime>Time Then
    Begin
      If Debug Then
        Writeln('Took too long to open bank');
      Exit;
    End;
    Wait(Random(100));
  Until BankScreen.IsOpen Or PinScreen.IsOpen;

  PinScreen.Enter(Players[CurrentPlayer].BankPin);

  If BankScreen.GetPackCount > 0 Then
    BankScreen.QuickDeposit(QUICK_DEPOSIT_INVENTORY);

  T.Start;
  Repeat
    Wait(Random(100));
    If BankScreen.Withdraw(10, WITHDRAW_AMOUNT_ALL, ['']) Then
      Break;

    If Not IsLoggedIn Then
      Exit;

    If T.GetTime>Time Then
    Begin
      Writeln('Out of logs');
      Writeln('Screenshot saved, send to Ashaman if you"re not really out of logs!');
      SaveScreenshot(ScriptPath + '/fail_.bmp');
      TerminateScript;
    End;
  Until False;

  BankScreen.Close;

  T.Start;
  Repeat
    Wait(Random(152));
    If Not IsLoggedIn Then
      Exit;
    If T.GetTime>Time Then
    Begin
      Writeln('Inventory still not full, WTF??');
      SaveScreenshot(ScriptPath + '/fail_.bmp');
      TerminateScript;
    End;
  Until (TabBackpack.IsItemInSlot(28));

  Result:=True;
  FUNCTIONSTOP:='BANKSHANTAY EXIT';
End;

function TSPSArea.walkToPos2(pos: TPoint; playerPos: TPoint): boolean;
var
  p: TPoint;
begin
  result := false;

  if (SPS_PosToMM(pos, playerPos, p)) then
  begin
    result := true;

    // if distance is less than 10 then there is no real point walking.
    if (distance(p, minimap.getCenterPoint()) < 1) then
      exit;

    mouse(p, MOUSE_LEFT);

    if (minimap.isFlagPresent(3000 + random(500))) then
      while (minimap.isPlayerMoving()) do
        minimap.waitPlayerMoving();

    if (minimap.isFlagPresent()) then  //case failed
      minimap.waitPlayerMoving();
  end;

  print('TSPSArea.walkToPos(): result = '+boolToStr(result));
end;

Procedure MoveAway;
Begin
  FUNCTIONSTOP:='MOVEAWAY ENTERED';
  If Not IsLoggedIn Then
    Exit;

  If (Length(Minimap.GetDots(MM_DOT_NPC,Minimap.GetBounds))>0) And ((CountColorTolerance(459779,Minimap.GetBounds,10)>5000) Or (CountColorTolerance(1774084,Minimap.GetBounds,10)>5000))Then
  Begin
    Players[CurrentPlayer].ExitToLobby;
    Wait(RandomRange(2000,3000));
    If Not Players[CurrentPlayer].Login Then
      TerminateScript;
    Wait(RandomRange(2000,3000));
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    Wait(RandomRange(2000,3000));
    Timeout.Start;
  End;

  Case GaussRangeInt(0,5) Of
    0: SPS.walkToPos2(Point(109,124),SPS.getPlayerPos());
    1: SPS.walkToPos2(Point(108,124),SPS.getPlayerPos());
    2: SPS.walkToPos2(Point(109,128),SPS.getPlayerPos());
    3: SPS.walkToPos2(Point(108,128),SPS.getPlayerPos());
    4: SPS.walkToPos2(Point(108,124),SPS.getPlayerPos());
  End;
  FUNCTIONSTOP:='MOVEAWAY EXIT';
End;

Function LightFire:Boolean;
Begin
  FUNCTIONSTOP:='LIGHTFIRE ENTERED';

  If Not IsLoggedIn Then
    Exit;

  Result := FirePresent;
  If Result Then
    Exit;

  If TabBackpack.ClickDTM(LogDTM,Mouse_Right,'ight',0,False) Then
    If TabBackpack.WaitForShift(GaussRangeInt(3000,4000)) Then
    Begin
      Result:= True;
      Wait(GaussRangeInt(3000,6000));
    End Else
      MoveAway;

  FUNCTIONSTOP:='LIGHTFIRE EXIT';
End;

Function FindFire: Boolean;
Var
  I: Integer;
  T: TTimeMarker;
Begin
  FUNCTIONSTOP:='FINDFIRE ENTERED';

  If Not IsLoggedIn Then
    Exit;

  Result:=False;

  ExitSquealOfFortune;
  ClaimSpinTicket;


  Wait(Random(100));

  For I:=0 To 1 Do
    If FindDTM(LogDTM,X,Y,TabBackpack.GetBounds) Then
    Begin
      If WaitFunc(@FirePresent,100,RandomRange(6000,7000)) Then
      Begin
        SendKeys(Players[CurrentPlayer].strings[0], 60 + Random(60), 60 + Random(60));
        Wait(GaussRangeInt(0, 100));
        If Toolscreen.IsOpen(RandomRange(3000,6000)) Then
        Begin
          ToolScreen.Select('bonfire');
          Result:= TabBackpack.WaitForShift(GaussRangeInt(2000,4000));
          If Result Then
            Exit Else
            Begin
              If I=1 Then
              Begin
                MoveAway;
                LightFire;
              End Else
                Wait(GaussRangeInt(3000,6000));

            End;
        End;
      End Else
      Begin
        MoveAway;
        LightFire;
      End;
    End;
  FUNCTIONSTOP:='FINDFIRE EXIT';
End;

function findSpirit: boolean;
var
  I,H,X,Y: Integer;
  mb: TBox;
  TPA,TPa2  : TPointArray;
  ATPA : T2DPointArray;
  spiritColors: T2DColorData;
Begin
  FUNCTIONSTOP:='FINDSPIRIT ENTERED';

  If Not IsLoggedIn Then
    Exit;

  Result:=False;

  mb:=Mainscreen.PlayerBox;
  mb.Edit(-35,-35,+35,+35);
                               //lighter                              darker
  spiritColors := [[6990571, 1, [2, [0.20, 1.04, 0.00]]], [5801433, 3, [2, [0.26, 2.19, 0.00]]]];

  if not (spiritColors.gatherIn(tpa, mb)) then
    exit(false);

  ATPA := TPA.Cluster(20);
  ATPA.FilterBetween(0,4);
  ATPA.SortBySize;

  SetLength(TPA,0);

  SmartImage.DebugATPA(ATPA);

  H := High(ATPA);

  For I := 0 To H Do
  Begin
    Writeln(Length(ATPA[i]));
    MiddleTPAEx(ATPA[I],X,Y);

    If (ChooseOption.OptionsExist(['Exam','mine','Examine','Canc','ncel','Cancel'],400)) Then
    Begin
      If Debug Then
        Writeln('Closing options menu');
      MouseBox(TabBackpack.GetBounds);
    End;

    Mouse(X+GaussRangeInt(-2,2),Y+GaussRangeInt(-2,2));
    If IsMouseOverText(['emon','spirit','rit','ee','Coll','-sp','ward','reward','ewar','act'],RandomRange(150,200)) Then
    Begin
      FastClick(Mouse_Right);
      If ChooseOption.Select(['Collect'],750) Then
      Begin
        SmartImage.Clear;
        Wait(GaussrangeInt(600,2000));
        Result:=True;
        Spirits:=Spirits+1;
        SetLength(ATPA,0);
        Exit;
      End;
    End;
  End;
  SetLength(ATPA,0);

  FUNCTIONSTOP:='FINDSPIRIT EXIT';
End;

Function Antiban: Boolean;
Var
  I: Integer;
Begin
  FUNCTIONSTOP:='ANTIBAN ENTERED';

  I := Random(600);
  Case I Of
    1..3:
      Begin
        MouseOffClient(Random(4));
        Wait(GaussRangeInt(1000,7000));
        Result := True;
      End;
    4..7:
      Begin
        hoverSkill(Skill_Firemaking);
        Wait(GaussRangeInt(1000,2000));
        TabBackpack.Open;
        Result := True;
      End;
    8..50:
      Begin
        mousemovingobject;
        Result := True;
      End;
    51..200:
      Begin
        SleepAndMoveMouse(GaussRangeInt(1000,2500));
        Result:=True;
      End;
    201..400:
      Begin
        MouseOffClient(Random(4));
        Wait(GaussRangeInt(1000,7000));
        Result:=True;
      End;
    401..600:
      Begin
        Wait(RandomRange(250, 1500));
        Result:=True;
      End;
  End;
  If TabBackpack.Count>5 Then
    Wait(GaussRangeInt(3500, 3600));

  FUNCTIONSTOP:='ANTIBAN EXIT';
End;

Procedure Waiting;
Var
  Inv1,Time,Inv2: Integer;
  B: TBox;
  T: TTimeMarker;
Begin
  FUNCTIONSTOP:='WAITING ENTERED';

  If Not IsLoggedIn Then
    Exit;

  T.Start;
  Inv1:= TabBackpack.Count;
  Inv2:= GaussRangeInt(0,5);
  Time:=GaussRangeInt(3500,5500);
  Repeat
    Wait(Random(100));
    If Not IsLoggedIn Then
      Exit;

    If CountLogs>Inv2 Then
      AntiBan;

    If (Players[CurrentPlayer].booleans[1]) And (TabBackpack.Count<22) And (FindSpirit) Then
          Break;


    If (Not FirePresent) And (Not isMouseOverMenuOpen(b)) Then
      Break;


    If Inv1>TabBackPack.Count Then
    Begin
      Inv1:=TabBackPack.Count;
      If Debug Then
        Writeln('Inventory changed');
      T.Start;
      Timeout.Start;
      Reset.Start;
    End;

    If (ClaimSpinTicket) Or (Not IsLoggedIn) Then
      Exit;
  Until (CountLogs=0) or (T.GetTime>Time);

  FUNCTIONSTOP:='WAITING EXIT';
End;

Procedure Mainloop;
Begin
  FUNCTIONSTOP:='MAINLOOP ENTERED';

  ExitSquealOfFortune;
  ClaimSpinTicket;

  If (CountLogs=0) Then
    WaitFunc(@BankShantay,Random(100),GaussRangeInt(10000,20000));

  LogCount:=LogCount+(CountLogs);

  If FindFire Then
    Waiting;

  ExitSquealOfFortune;
  ClaimSpinTicket;

  If CountLogs=0 Then
    ProgressReport;

  If Timeout.GetTime>TimeoutLength Then
  Begin
    Writeln('Something went wrong, shutting down');
    SaveScreenshot(ScriptPath + '/fail_.bmp');
    Players[CurrentPlayer].Logout;
    TerminateScript;
  End;

  If Reset.GetTime>ResetLength Then
  Begin
    Writeln('Something went wrong, resetting stuff');
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    BankShantay;
    Reset.Start;
  End;

  If Not IsLoggedIn Then
  Begin
    If Players[CurrentPlayer].Login Then
    Begin
      Wait(GaussRangeInt(2000,4000));
      Minimap.ClickCompass;
      MainScreen.SetAngle(MS_ANGLE_HIGH);
      Reset.Start;
      ExitSquealOfFortune;
      ClaimSpinTicket;
    End Else
      Exit;
  End;

  If Players[CurrentPlayer].booleans[0] Then
    BreakHandler(Players[CurrentPlayer].integers[0],Players[CurrentPlayer].integers[1],15,7);
  Wait(Random(100));

  FUNCTIONSTOP:='MAINLOOP exit';
End;

Procedure LastRun;
Begin
  Writeln(FunctionStop);
End;


Procedure Setup;
Begin
  ClearDebug;
  AutoUpdateMe;

  SmartEnableDrawing := True;

  initPlayerForm(); // initiate your settings
  runPlayerForm();  // run the form

  // use this so the script doesn't continue if the user exits out of the form
  if (not playerForm.isScriptReady) then
    terminatescript;

  declarePlayers();
  smartPlugins := ['OpenGL32.dll','d3d9.dll'];

  SetupSRL;
  RequirementsCheck;
  SPS.Setup('0_0SP', 'Runescape_Surface\');

  AddOnTerminate('Fr33DTMs');
  SetDTMs;

  AddOnTerminate('LastRun');

  If Not IsLoggedIn Then
  Begin
    If Not Players[CurrentPlayer].Login Then
      TerminateScript;

    Writeln('Just loggedin, waiting a bit');
    Wait(RandomRange(6000,10000));
  End;

  If Not Debug Then
    DisableSRLDebug:=True else
    DisableSRLDebug := false;

  clearDebug;

  if conversationBox.continue(true, true) then
    Wait(RandomRange(3000,2000));

  Minimap.ClickCompass;
  MainScreen.SetAngle(MS_ANGLE_HIGH);

  StartingExperience := ChatBox.GetXP;

  Players[CurrentPlayer].FindMod := False;
  ExitSquealOfFortune;
  ClaimSpinTicket;

  LogCount:=CountLogs;

  Timeout.Start;
  Reset.Start;
  TimeoutLength:= GaussRangeInt(600000,650000);
  ResetLength:= GaussRangeInt(250000,400000);



  SmartImage.Clear;

  Writeln('Looks like we are doing bonfires at Shantay Pass!');

  Writeln('Lets get this show on the road!');
End;

Begin
  Setup;

  While (Players.GetActive() > 0) Do
    If Not POSDebug Then
      Mainloop Else
      SPS.DebugPlayerPos;
End.
